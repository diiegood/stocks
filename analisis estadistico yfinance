import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta
import quadprog 
import numpy as  np
import matplotlib.pyplot as plt
import scipy.stats as st
import os 
import math 


"Analisis de la accion"

#activos a analizar  ##########################################################

"WALMEX.MX", "ALFAA.MX","KOFUBL.MX","GFNORTEO.MX"

ticker = "WALMEX.MX"
ric = ticker

end_date = datetime.today().date()
start_date = end_date - timedelta(days=180)

# Descargar datos diarios
stock = yf.download(
    ticker,
    start=start_date.strftime("%Y-%m-%d"),
    end=end_date.strftime("%Y-%m-%d"),
    interval="1d" #frecuencia
    )

stock = stock[["Close"]].reset_index()

#stock.index.name = "Date"
stock.head()
stock.tail()
stock.shape

###############################################################################

"Crear la serie de tiempo de la accion"

t = pd.DataFrame()  # Crear un data frame vacio , para guardar las columnas que se crearan

# Proceso de datos para los calculos
#si voy a meter una accion americana o extrangera cambiar Fecha a / Date  y Cierre a / Close
t["date"] = pd.to_datetime(stock["Date"], dayfirst=True )  # Convertir la columna "Date" a serie de tiempo
t["close"] = stock["Close"]  # Asignar la columna "Close"
t = t.sort_values(by="date", ascending=True)  # Ordenar por fecha
t["close_previous"] = t["close"].shift(1)  # Crear columna del cierre anterior


"Formas de Calcular el rendimiento"   #########################################
#t["return_close"] = t["close"] / t["close_previous"] - 1 #rendimiento en base a (P1 / P0)
t["return_close"] =  np.log(t["close"] / t["close_previous"]) #rendimiento en base a log(P1/P0)
#t["return_close"] = raw_data["Cierre"].pct_change()  #rendimiento en base a ((P1 - P0 )/P0)-1

t = t.dropna()  # Eliminar filas con valores NaN
t = t.reset_index(drop=True)  # Reiniciar el i­ndice



######################## Funcion del objeto simulador #########################

class SimulationInputs:
    def __init__(self):
        self.df = None
        self.scale = None
        self.mean = None
        self.std = None
        self.rv_type = None
        self.VaR_95 = None
        self.VaR_99 = None
        self.size = None
        self.decimals = None

class Simulator:
    # Constructor
    def __init__(self, inputs):
        self.inputs = inputs
        self.str_title = None
        self.vector = None
        self.mean = None
        self.volatility = None
        self.skewness = None
        self.kurtosis = None
        self.VaR_95 = None
        self.VaR_99 = None
        self.jb_stat = None
        self.p_value = None
        self.is_normal = None
        
    def generate_vector(self):
        self.str_title = self.inputs.rv_type
        if self.inputs.rv_type == 'standard_normal':
            self.vector = np.random.standard_normal(self.inputs.size)
        elif self.inputs.rv_type == 'normal':
            self.vector = np.random.normal(self.inputs.mean, self.inputs.std, self.inputs.size)
        elif self.inputs.rv_type == 'student':
            self.vector = np.random.standard_t(df=self.inputs.df, size=self.inputs.size)
            self.str_title += f' df={self.inputs.df}'
        elif self.inputs.rv_type == 'uniform':
            self.vector = np.random.uniform(size=self.inputs.size)
        elif self.inputs.rv_type == 'exponential':
            self.vector = np.random.exponential(scale=self.inputs.scale, size=self.inputs.size)
            self.str_title += f' scale={self.inputs.scale}'
        elif self.inputs.rv_type == 'chi-squared':
            self.vector = np.random.chisquare(df=self.inputs.df, size=self.inputs.size)
            self.str_title += f' df={self.inputs.df}'
            
    def compute_stats(self):
        self.mean = st.tmean(self.vector)
        self.volatility = st.tstd(self.vector)
        self.skewness = st.skew(self.vector)
        self.VaR_95 = np.percentile(self.vector, 5)
        self.VaR_99 = np.percentile(self.vector, 1)
        self.kurtosis = st.kurtosis(self.vector)
        self.jb_stat = self.inputs.size / 6 * (self.skewness**2 + 1/4 * self.kurtosis**2)
        self.p_value = 1 - st.chi2.cdf(self.jb_stat, df=2)
        self.is_normal = (self.p_value > 0.05)  # Equivalente a jb < 6
        
    def plot(self):
        self.str_title += f'\nmean={np.round(self.mean, self.inputs.decimals)} | volatility={np.round(self.volatility, self.inputs.decimals)}' \
                          f'\nskewness={np.round(self.skewness, self.inputs.decimals)} | kurtosis={np.round(self.kurtosis, self.inputs.decimals)}' \
                          f'\nJB stat={np.round(self.jb_stat, self.inputs.decimals)} | p-value={np.round(self.p_value, self.inputs.decimals)}' \
                          f'\nis_normal={self.is_normal}'
        plt.figure()
        plt.hist(self.vector, bins=100)
        plt.title(self.str_title)
        plt.show()

################################ Inputs para simulacion #######################

inputs = SimulationInputs()
inputs.rv_type = ric + '| real time '
inputs.decimals = 5  # Decimales a mostrar

# Calculos y simulacion.
sim = Simulator(inputs)
sim.vector = t['return_close'].values # Generar vector
sim.inputs.size = len(sim.vector)
sim.str_title = sim.inputs.rv_type
sim.compute_stats()  # Calcular estadisticas
sim.plot()  # Graficar

#valores calculados
rendimiento_diario = sim.mean #calculo de la media
rendimiento_diario = rendimiento_diario * 100
rendimiento_anual = sim.mean * 252 #se calcula de la media anualizada (se multiplica por los dias de mercado 252)
volatilidad_diaria =sim.volatility #calculo de volatilidad
volatilidad_diaria = volatilidad_diaria * 100
volatilidad_anual = sim.volatility * np.sqrt(252)   #calculo de la volatilidad anualizada
volatilidad_anual = volatilidad_anual * 100
#volatilidad * raiz (T) o  tambien (volatilidad * 16 (raiz cuadrada de 256 = 16))
VaR_95 = sim.VaR_95
VaR_95 = VaR_95 * 100
VaR_99 = sim.VaR_99
VaR_99 = VaR_99 * 100


"para el calculo sharpe" #el cociente debe ser 2 o mayor en una estrategia de inversion.
#se pide que sea mayor a 2 porque entonces, los rendimientos que se obtienen, van a ser positivos.
#ya que en 2 todo el intervalo de confianza va ser positivo 
#( sharpe =  mu / sigma )
#sharpe mayor a 2 es suponer que los rendimientos son normales 
#por lo tanto el intervalo de confianza es totalmente positivo

#Segun el despeje:

"mu / sigma >2 "
"mu > 2 * sigma "
"mu - 2 sigma > 0 "  #mu - 2 sigma es positivo

#Por lo tanto con el sharpe > 2 ,  el rendimiento que se ofrece es positivo en un 95% de los casos (intervalo de confianza)
#siendo diferente al calculado anteriormente, que es el de mean * 252 (media anaulizada) , siendo mas la media aproximada
#sharpe ratio, se usa como parametro para tener mayor precision sobre el rendimiento real, teniendo en cuenta los intervalos de confianza
#suponiendo que los rendimientos son normales o siguen un movimiento browniano

"""
Sharpe ratio es el riesgo ajustado de una inversion 

Indica la relacion entre el costo de oportunidad de la relacion riesgo / rendimiento de la inversion
por cada unidad de riesgo incurrida o volatilidad cuato rendimiento estoy ganando quitando la 
tasa de los bonos o la libre de riesgo.

"""

#se calcula media anualizada /  volatilidad anualizada (sin contemplar tasa libre de riesgo)
sharpe_ratio = sim.mean * 252 / (sim.volatility*np.sqrt(252))
sharpe_ratio

#tomando en cuenta la tasa cetes a 28 dias de 7.65%   21/7/25
risk_free_rate = 0.0765
sharpe_ratio_rf = ( sim.mean * 252 ) - risk_free_rate  / (sim.volatility*np.sqrt(252))
sharpe_ratio

#analisis de metricas
print("Se tiene un rendimiento diario de " , rendimiento_diario * 100, "%")
print("Se tiene una volatilidad diaria de ", volatilidad_diaria * 100 ,"%")
print("Tenemos un rendimiento esperado anual aproximado de ", rendimiento_anual *100 ,"%" )
print("Dada la volatilidad anual del activo en", volatilidad_anual* 100 , "%")
print("Tenemos un sharpe ratio de ", sharpe_ratio )
print ("Sharpe ratio teniendo en cuenta la tasa libre de riesgo de ", sharpe_ratio_rf )
print("Tiene skewness positiva por que la gran mayoria de los dias son positivos")
print("Tiene media positiva porque las ganancias suelen ser positivas")
#si la curtosis de la distribucion es mayor a 3 significa que no es normal la distribucion
print("La curtosis en exceso es positiva, tiene colas muy largas tiene muchas anomalias en cuanto a los precios mas positivos ")
#este parametro sirve para ver que tan significativa es la media comparada con la volatilidad
print("EL valor en Riesgo con un 95% de confianza es de ", VaR_95, "%")
print("EL valor en Riesgo con un 99% de confianza es de ", VaR_99, "%")
sharpe = sharpe_ratio *100

print("Se interpreta por cada unidada de riesgo que se aumenta 1% de volatilidad extra o riesgo, se va ganar un", sharpe_ratio ,"% de rendimiento extra")


#se busca que sea mayor a 1 para poder tener un rendimiento arriba del punto de riesgo, justificando el riesgo

#Sharpe de mas de 2 / sea 5 o 10 es excelente entre mayor mejor.
#porque el intervalo de confianza es mas pequeño por lo que hay mayor certeza sobre la media a largo plazo

#Parametros importantes

#media como parametro de media aproxiamada
#sharpe ratio como parametro de media real , teniendo en cuenta el intervalo de confianza
#volatilidad

###############################################################################

#para construir la serie de tiempo , es para el comportamiento del activo de su precio a lo largo del tiempo, no del rendimiento
# / x =  tiempo (fecha) , y = precio (precio cierre) , grid = para que se vean rallitas en la grafica (True)

plt.figure()

#funcionalidad de dataframe .plot, para graficar diferentes tipos de graficas:
    #kind = "line", "bar", "hist", "area", "pie", "scatter", "hexbin", "box", "density", "kde"
t.plot(kind='line', x='date', y='close', grid=True, color='red',
       label=ric, title='Serie de tiempo de precio cierre ' + ric)

plt.show()

"Calculo del VaR por dia"

confidence_level = 0.95
z_score_95 = st.norm.ppf(confidence_level)  # z = 1.65 aprox para 95%

# Función para calcular VaR paramétrico
def calc_var(days, mean, std, z):
    mu_t = mean * days
    sigma_t = std * np.sqrt(days)
    var = mu_t - z * sigma_t
    return var * 100  # En porcentaje

# Cálculos de VaR a diferentes días
VaR_3d  = calc_var(3, sim.mean, sim.volatility, z_score_95)
VaR_5d  = calc_var(5, sim.mean, sim.volatility, z_score_95)
VaR_10d = calc_var(10, sim.mean, sim.volatility, z_score_95)
VaR_15d = calc_var(15, sim.mean, sim.volatility, z_score_95)

# Mostrar resultados
print("\n--------- Valor en Riesgo (VaR) Paramétrico 95% ---------")
print(f"VaR a 3 días:  {VaR_3d:.2f}%")
print(f"VaR a 5 días:  {VaR_5d:.2f}%")
print(f"VaR a 10 días: {VaR_10d:.2f}%")
print(f"VaR a 15 días: {VaR_15d:.2f}%")

###############################################################################
###############################################################################
###############################################################################

"Monte Carlo"

retornos = t["return_close"]
mu = np.mean(retornos)
sigma = np.std(retornos) * np.sqrt(252)

print(f"Retorno esperado (mu): {mu:.5f}")
print(f"Volatilidad (sigma): {sigma:.5f}")

S0 = t['close'].iloc[-1]  # Último precio ajustado
T = 10 / 252  # n días, convertido a años
n_steps = 100  # Número de pasos en la simulación
n_simulations = 1000  # Número de simulaciones

dt = T / n_steps

# Simulación de las trayectorias de precios
price_paths = np.zeros((n_steps + 1, n_simulations))
price_paths[0] = S0

for i in range(1, n_steps + 1):
    Z = np.random.standard_normal(n_simulations)  # Números aleatorios para la simulación
    price_paths[i] = price_paths[i - 1] * np.exp((mu - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z)

# Cálculo del intervalo de confianza
final_prices = price_paths[-1]  # Precios al final del periodo simulado
ci_lower = np.percentile(final_prices, 2.0)  # Límite inferior del 10%
ci_upper = np.percentile(final_prices, 95.0)  # Límite superior del 90%

# Cálculo del precio probable (mediana)
precio_median = np.median(final_prices)

# Imprimir los resultados
print(f"Precio probable (mediana): {precio_median:.2f}")

# Cálculo de la probabilidad de alcanzar un precio objetivo
precio_objetivo = 60  # Ejemplo de precio objetivo
probabilidad = np.mean(final_prices >= precio_objetivo)

# Resultados
print(f"Intervalo de confianza al 99%: [{ci_lower:.2f}, {ci_upper:.2f}]")
print(f"Probabilidad de alcanzar el precio objetivo de {precio_objetivo}: {probabilidad:.2%}")

# Gráfico de las trayectorias simuladas
plt.style.use('dark_background')
plt.figure(figsize=(20, 12))
for i in range(1000):  # Mostrar solo n simulaciones para no saturar el gráfico
    plt.plot(price_paths[:, i], lw=1.5, alpha=0.1)

plt.axhline(ci_lower, color='red', linestyle='--', label='IC 1% Inferior')
plt.axhline(ci_upper, color='green', linestyle='--', label='IC 1% Superior')
plt.title("Simulación de Precios de " + ticker + " con GBM a 10 días")
plt.xlabel('Tiempo (días)')
plt.ylabel('Precio del Activo')
plt.legend()
plt.grid(True)
plt.show()

